/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java application project to get you started.
 * For more details on building Java & JVM projects, please refer to https://docs.gradle.org/8.13/userguide/building_java_projects.html in the Gradle documentation.
 */

plugins {
    // Apply the java-library plugin to add support for Java Library
    `java-library`
    // Add the JMH plugin
    id("me.champeau.jmh") version "0.7.3"
}

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}

dependencies {
    // Use JUnit test framework (Example, add if you have tests)
    // testImplementation(libs.junit)

    // This dependency is used by the application (Example, add if needed)
    // implementation(libs.guava)

    // Add JMH dependencies
    val jmhVersion = "1.37"
    jmh("org.openjdk.jmh:jmh-core:$jmhVersion")
    jmhAnnotationProcessor("org.openjdk.jmh:jmh-generator-annprocess:$jmhVersion")
}

// Apply a specific Java toolchain to ease working on different environments.
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

// The JMH plugin automatically configures the 'jmh' source set.
// Explicit configuration is usually not needed unless customizing paths.
// sourceSets {
//     jmh {
//         java.srcDirs("src/jmh/java")
//     }
// }

jmh {
    fork.set(1)              // -f 1
    warmupIterations.set(5)  // -wi 5
    iterations.set(10)       // -i 10

    // JVM args for the forked benchmark process
    jvmArgs.set(listOf(
        "--add-exports=java.base/jdk.internal.vm.annotation=ALL-UNNAMED",
        "-XX:-RestrictContended"
    ))
}

tasks.withType<JavaCompile>().configureEach {
    if (name.contains("jmh", ignoreCase = true)) {
        options.compilerArgs.add("--add-exports")
        options.compilerArgs.add("java.base/jdk.internal.vm.annotation=ALL-UNNAMED")
    }
}

tasks.register("generateBlobs") {
    group = "application"
    description = "Generates test blob files"
    dependsOn("compileJava")
    
    doLast {
        project.javaexec {
            mainClass.set("fi.lauripiispanen.benchmarks.io.BlobGenerator")
            classpath = sourceSets["main"].runtimeClasspath
        }
    }
}

val os = org.gradle.internal.os.OperatingSystem.current()
val nativeSourceDir = "src/native"

val cFile = if (os.isLinux) "io_uring_reader.c" else "dummy_reader.c"
val sourcePath = file("$nativeSourceDir/$cFile")

val outputLib = when {
    os.isMacOsX -> "libio_uring_reader.dylib"
    os.isLinux -> "libio_uring_reader.so"
    else -> throw GradleException("Unsupported OS for native build")
}
val nativeLibPath = layout.buildDirectory.file("nativeLibs")
val outputPath = layout.buildDirectory.file("nativeLibs/$outputLib")

val jniIncludes = listOf(
    "${System.getenv("JAVA_HOME")}/include",
    if (os.isMacOsX) "${System.getenv("JAVA_HOME")}/include/darwin" else "${System.getenv("JAVA_HOME")}/include/linux"
)

tasks.register<Exec>("compileNative") {
    group = "build"
    description = "Compiles native JNI library"

    inputs.file(sourcePath)
    outputs.file(outputPath)

    // Linux-specific flags and libraries for io_uring
    val linuxFlags = if (os.isLinux) {
        listOf("-luring")
    } else {
        listOf()
    }

    commandLine = listOf(
        "gcc", "-fPIC", "-shared",
        "-o", outputPath.get().asFile.absolutePath,
        sourcePath.absolutePath
    ) + jniIncludes.map { "-I$it" } + linuxFlags
}

val generateJniHeaders = tasks.register("generateJniHeaders", Exec::class) {
    val classOutput = layout.buildDirectory.dir("classes/java/jmh")

    inputs.dir("src/jmh/java")
    outputs.dir("src/native")

    doFirst {
        println("Generating JNI headers...")
    }

    commandLine = listOf(
        "javac", "-h", "src/native",
        "-d", classOutput.get().asFile.absolutePath,
        "src/jmh/java/fi/lauripiispanen/benchmarks/io/IoUringBridge.java"
    )
}

tasks.named("compileJava") {
    dependsOn(generateJniHeaders)
}

tasks.register("runJmh", Exec::class) {
    group = "benchmarks"
    description = "Runs JMH benchmarks with CompletableFuture tests"
    
    dependsOn("jmhJar")
    
    // Allow overriding parameters via project properties
    val forks = project.findProperty("jmh.forks") ?: "1"
    val warmupForks = project.findProperty("jmh.warmupForks") ?: "1"
    val warmupIterations = project.findProperty("jmh.warmupIterations") ?: "1"
    val iterations = project.findProperty("jmh.iterations") ?: "3"
    val warmupTime = project.findProperty("jmh.warmupTime") ?: "3s"
    val blobDir = project.findProperty("jmh.blobDir") 
        ?: "${System.getProperty("user.home")}/javatricks/app/blobs"
    val includes = project.findProperty("jmh.includes") ?: ".*IoUring.*"
    val nativeLibPath = nativeLibPath.get().asFile.absolutePath
    
        workingDir = projectDir
        commandLine = listOf(
            "java",
            "-Djava.library.path=$nativeLibPath",
            "-jar",
            "${layout.buildDirectory.get()}/libs/app-jmh.jar",
            "-f", forks.toString(),
            "-wf", warmupForks.toString(),
            "-wi", warmupIterations.toString(),
            "-i", iterations.toString(),
            "-w", warmupTime.toString(),
            "-p", "blobDir=$blobDir",
            "--",
            "-includes", includes.toString()
        )
}
